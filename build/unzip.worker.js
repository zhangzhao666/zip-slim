let e=null;const t=(t,r=0)=>{e||(()=>{const t=Int32Array,r=new t(256),n=new t(4096);let a,s,o;for(s=0;s<256;s++){a=s;for(let e=0;e<8;e++)a=1&a?-306674912^a>>>1:a>>>1;n[s]=r[s]=a}for(s=0;s<256;s++)for(o=r[s],a=256+s;a<4096;a+=256)o=n[a]=o>>>8^r[255&o];for(e=[r],s=1;s<16;s++)e[s]=n.subarray(256*s,256*(s+1))})();const[n,a,s,o,i,f,c,l,w,g,u,d,U,m,p,y]=e;let b=~r,h=0;const D=t.length-15;for(;h<D;)b=y[t[h++]^255&b]^p[t[h++]^b>>8&255]^m[t[h++]^b>>16&255]^U[t[h++]^b>>>24]^d[t[h++]]^u[t[h++]]^g[t[h++]]^w[t[h++]]^l[t[h++]]^c[t[h++]]^f[t[h++]]^i[t[h++]]^o[t[h++]]^s[t[h++]]^a[t[h++]]^n[t[h++]];for(;h<t.length;)b=b>>>8^n[255&(b^t[h++])];return~b>>>0},r=(new TextEncoder,new TextDecoder("utf-8")),n="undefined"!=typeof DecompressionStream;self.onmessage=async e=>{try{const a=await async function(e){const a=new DataView(e.buffer),s=[];let o=0;for(;o<e.length&&67324752===a.getUint32(o,!0);){o+=4;const i=a.getUint16(o+4,!0),f=a.getUint16(o+6,!0),c=a.getUint16(o+8,!0),l=a.getUint32(o+10,!0),w=a.getUint32(o+14,!0),g=a.getUint32(o+18,!0),u=a.getUint16(o+22,!0),d=a.getUint16(o+24,!0);o+=26;const U=r.decode(e.subarray(o,o+u));o+=u+d;const m=new Date(1980+(c>>9&127),(c>>5&15)-1,31&c,f>>11&31,f>>5&63,2*(31&f));let p;if(0===i){if(p=e.subarray(o,o+w),t(p)!==l)throw new Error(`CRC32 mismatch for ${U}`)}else{if(8!==i||!n)throw new Error(`Unsupported compression method ${i}`);{const t=new Uint8Array(w+18);t.set([31,139,8,0,0,0,0,0,0,3]),t.set(e.subarray(o,o+w),10),new DataView(t.buffer).setUint32(w+10,l,!0),new DataView(t.buffer).setUint32(w+14,g,!0);const r=new DecompressionStream("gzip"),n=r.writable.getWriter(),a=r.readable.getReader();n.write(t),n.close(),p=new Uint8Array(g);let s=0;for(;;){const{value:e,done:t}=await a.read();if(t)break;p.set(e,s),s+=e.length}}}s.push({name:U,data:p.buffer,lastModified:m.getTime()}),o+=w}return s}(new Uint8Array(e.data.zipData));self.postMessage({result:a},{transfer:a.map((e=>e.data))})}catch(e){self.postMessage({error:e})}};